import type { PlistDictionary } from '../../../lib/types.js';
import { BaseService } from '../base-service.js';
import { ChannelFragmenter } from './channel-fragmenter.js';
import { Channel } from './channel.js';
import { DTXMessage, DTX_CONSTANTS, MessageAux } from './dtx-message.js';
/**
 * DVTSecureSocketProxyService provides access to Apple's DTServiceHub functionality
 * This service enables various instruments and debugging capabilities through the DTX protocol
 */
export declare class DVTSecureSocketProxyService extends BaseService {
    static readonly RSD_SERVICE_NAME = "com.apple.instruments.dtservicehub";
    static readonly BROADCAST_CHANNEL = 0;
    private connection;
    private socket;
    private supportedIdentifiers;
    private lastChannelCode;
    private curMessageId;
    private readonly channelCache;
    private readonly channelMessages;
    private isHandshakeComplete;
    private readBuffer;
    constructor(address: [string, number]);
    /**
     * Connect to the DVT service and perform handshake
     */
    connect(): Promise<void>;
    /**
     * Get supported service identifiers (capabilities)
     */
    getSupportedIdentifiers(): PlistDictionary;
    /**
     * Create a communication channel for a specific service identifier
     * @param identifier The service identifier (e.g., 'com.apple.instruments.server.services.LocationSimulation')
     * @returns The created channel instance
     */
    makeChannel(identifier: string): Promise<Channel>;
    /**
     * Send a DTX message on a channel
     * @param channel The channel code
     * @param selector The ObjectiveC method selector
     * @param args Optional message arguments
     * @param expectsReply Whether a reply is expected
     */
    sendMessage(channel: number, selector?: string | null, args?: MessageAux | null, expectsReply?: boolean): Promise<void>;
    /**
     * Receive a plist message from a channel
     * @param channel The channel to receive from
     * @returns Tuple of [decoded data, auxiliary values]
     */
    recvPlist(channel?: number): Promise<[any, any[]]>;
    /**
     * Receive a raw message from a channel
     * @param channel The channel to receive from
     * @returns Tuple of [raw data, auxiliary values]
     */
    recvMessage(channel?: number): Promise<[Buffer | null, any[]]>;
    /**
     * Close the DVT service connection
     */
    close(): Promise<void>;
    /**
     * Perform DTX protocol handshake to establish connection and retrieve capabilities
     */
    private performHandshake;
    private extractSelectorFromResponse;
    private extractCapabilitiesFromAuxData;
    /**
     * Drain any buffered messages that arrived during handshake
     */
    private drainBufferedMessages;
    /**
     * Receive packet fragments until a complete message is available for the specified channel
     */
    private recvPacketFragments;
    /**
     * Read exact number of bytes from socket with buffering
     */
    private readExact;
    /**
     * Check if response contains an NSError and throw if present
     */
    private checkForNSError;
    /**
     * Archive a value using NSKeyedArchiver format for DTX protocol
     */
    private archiveValue;
    /**
     * Archive a selector string for DTX messages
     */
    private archiveSelector;
    /**
     * Build auxiliary data buffer with NSKeyedArchiver encoding for objects
     */
    private buildAuxiliaryData;
    /**
     * Parse auxiliary data from buffer
     *
     * The auxiliary data format can be:
     * 1. Standard format: [magic:8][size:8][items...]
     * 2. NSKeyedArchiver bplist format (for handshake responses)
     */
    private parseAuxiliaryData;
    /**
     * Parse auxiliary data in NSKeyedArchiver bplist format
     */
    private parseAuxiliaryAsBplist;
    /**
     * Parse auxiliary data in standard DTX format
     */
    private parseAuxiliaryStandard;
    /**
     * Parse a single auxiliary value
     */
    private parseAuxiliaryValue;
}
export { Channel, ChannelFragmenter, DTXMessage, MessageAux, DTX_CONSTANTS };
export { decodeNSKeyedArchiver, NSKeyedArchiverDecoder, } from './nskeyedarchiver-decoder.js';
export type { DTXMessageHeader, DTXMessagePayloadHeader, MessageAuxValue, } from './dtx-message.js';
//# sourceMappingURL=index.d.ts.map